---
title: "Main lessons from 'The Pragmatic Programmer'"
date: 2025-12-07
category: Statistics, mathematics and computer science
layout: post
---

The objective of this guide is to compile quick summaries from Chapters 1-3 of **CITE**. The summaries do not replace the content of each chapter, but can be useful as quick reference points.

## Chapter 1: A Pragmatic Philosophy

### Topic 1: It's Your Life

- You have agency.
- Does your work environment suck? Is your job boring? Try to fix it. But don’t try forever.
- If technology seems to be passing you by, make time (in your own time) to study new stuff that looks interesting.
- Want to work remotely? Have you asked? If they say no, then find someone who says yes.\
- This industry gives you a remarkable set of opportunities. Be proactive, and take them.

### Topic 2: The Cat Ate My Source Code

- Despite thorough testing, good documentation, and solid automation, things go wrong. Deliveries are late. Unforeseen technical problems come up. These things happen, and we try to deal with them as professionally as we can. This means being honest and direct.
- Trust in a team is absolutely essential for creativity and collaboration.
- You have the right not to take on a responsibility for an impossible situation, or one in which the risks are too great, or the ethical implications too sketchy.
- When you do accept the responsibility for an outcome, you should expect to be held accountable for it. When you make a mistake (as we all do) or an error in judgment, admit it honestly and try to offer options.
- Don’t blame someone or something else, or make up an excuse.
- When you find yourself saying, “I don’t know,” be sure to follow it up with “—but I’ll find out.” It’s a great way to admit what you don’t know, but then take responsibility like a pro.

### Topic 3: Software Entropy

- Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered.
- Don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

### Topic 4: Stone Soup and Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes—you know it’s right. But ask permission to tackle the whole thing and you’ll be met with delays and blank stares.
- Work out what you can reasonably ask for. Develop it well. Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added…’’ Pretend it’s not important. Sit back and wait for them to start asking you to add the functionality you originally wanted.

### Topic 5: Good-Enough Software

- You can discipline yourself to write software that’s good enough—good enough for your users, for future maintainers, for your own peace of mind (the phrase "good enough" does not imply sloppy or poorly produced code).
- Involve your users in the trade-off: Sometimes there’ll be no choice. However, if you’re working on a brand-new product, you’ll have different constraints. Surprisingly, many users would rather use software with some rough edges today than wait a year for the shiny, bells-andwhistles version.
- Know when to stop: Don’t spoil a perfectly good program by overembellishment and overrefinement. Move on, and let your code stand in its own right for a while.


### Topic 6: Your Knowledge Portfolio

- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios.
- To be successful in your career, you must invest in your knowledge portfolio: Invest regularly, diversify, manage risk, buy low (sell high) and review and rebalance. 
- Suggested goals: Learn new languages, read technical books, read nontechnical books, take classes, participate in local user groups and meetups, experiment with different environments and stay current.
- Opportunities for learning: 
  - Somebody asks you a question. You don’t have the faintest idea what the answer is, and freely admit as much. Take it as a personal challenge to find the answer. Ask around. If you can’t find the answer yourself, find out who can.
  - Plan ahead. Always have something to read in an otherwise dead moment. Time spent waiting for doctors and dentists can be a great opportunity to catch up on your reading.
- Think critically about what you read and hear. Beware of the zealots who insist that their dogma provides the only answer. Just because a web search engine lists a hit first doesn’t mean that it’s the best match. Just because a bookstore features a book prominently doesn’t mean it’s a good book, or even popular.
- Suggested questions: Ask the "Five Whys". Who does this benefit? What’s the context? When or Where would this work? Why is this a problem?

### Topic 7: Communicate!

- Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people. A good idea is an orphan without effective communication.
- Know your audience: By making the appropriate pitch to each group, you’ll get them all excited about your project. As with all forms of communication, the trick here is to gather feedback. Don’t just wait for questions: ask for them. Look at body language, and facial expressions.
- Know what you want to say: Plan what you want to say. Write an outline. Then ask yourself, “Does this communicate what I want to express to my audience in a way that works for them?” Refine it until it does. When you’re faced with an important meeting or a chat with a major client, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.
- Choose your moment: As part of understanding what your audience needs to hear, you need to work out what their priorities are. Make what you’re saying relevant in time, as well as in content. Sometimes all it takes is the simple question, “Is this a good time to talk about…?’’
- Choose a style: Adjust the style of your delivery to suit your audience. Some people want a formal “just the facts’’ briefing. Others like a long, wide-ranging chat before getting down to business. What is their skill level and experience in this area? Are they experts? Newbies? Do they need hand-holding or just a quick tl;dr? If in doubt, ask.
- Make it look good: Your ideas are important. They deserve a good-looking vehicle to convey them to your audience. Learn how to set page headers and footers. Check the spelling, first automatically and then by hand.
- Involve your audience: We often find that the documents we produce end up being less important than the process we go through to produce them. If possible, involve your readers with early drafts of your document. Get their feedback, and pick their brains. You’ll build a good working relationship, and you’ll probably produce a better document in the process.
- Be a listener: There’s one technique that you must use if you want people to listen to you: listen to them. If you don’t listen to them, they won’t listen to you. Encourage people to talk by asking questions, or ask them to restate the discussion in their own words. Turn the meeting into a dialog, and you’ll make your point more effectively. Who knows, you might even learn something.
- Get back to people: how often do you fail to get back to people when they send you an email or a memo asking for information or requesting some action? In the rush of everyday life, it’s easy to forget. Always respond to emails and voicemails, even if the response is simply “I’ll get back to you later.’’
- Documentation: Pragmatic Programmers embrace documentation as an integral part of the overall development process. It’s easy to produce good-looking documentation from the comments in source code. Restrict your non-API commenting to discussing why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant. Commenting source code gives you the perfect opportunity to document those elusive bits of a project that can’t be documented anywhere else: engineering trade-offs, why decisions were made, what other alternatives were discarded, and so on.

## Chapter 2: A Pragmatic Approach

### Topic 8: The Essence of Good Design

- Good Design Is Easier to Change Than Bad Design.
- Easier to Change. ETC. Every design principle out there is a special case of ETC.
- ETC is a value, not a rule: it should be floating just behind your conscious thought, subtly nudging you in the right direction.
- You may need to spend a week or so deliberately asking yourself “did the thing I just did make the overall system easier or harder to change?”

### Topic 9: DRY - The Evils of Duplication

- When we perform maintenance, we have to find and change the representations of things—those capsules of knowledge embedded in the application. The problem is that it’s easy to duplicate knowledge in the specifications, processes, and programs that we develop, and when we do so, we invite a maintenance nightmare—one that starts well before the application ships.
- The only way to develop software reliably, and to make our developments easier to understand and maintain, is to follow what we call the DRY (Don’t Repeat Yourself) principle: Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
- The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others.
- Dry is more than code: DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.
- Make It Easy to Reuse: What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself. If it isn’t easy, people won’t do it. And if you fail to reuse, you risk duplicating knowledge.

### Topic 10: Orthogonality

- In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap databases without changing the interface. Eliminate effects between unrelated things.
- Benefits of orthogonality: We want to design components that are self-contained (independent, and with a single, well-defined purpose). You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.
- Orthogonality in design: There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: If I dramatically change the requirements behind a particular function, how many modules are affected? In an orthogonal system, the answer should be “one.’ Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes?
- Orthogonality in toolkits and libraries: When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn’t be there.
- Orthogonality in coding: Every time you write code you run the risk of reducing the orthogonality of your application. There are several techniques you can use to maintain orthogonality: keep your code decoupled, avoid global data, avoid similar functions.
- Orthogonality in testing: Writing unit tests is itself an interesting test of orthogonality. What does it take to get a unit test to build and run? Do you have to import a large percentage of the rest of the system’s code? If so, you’ve found a module that is not well decoupled from the rest of the system. Bug fixing is also a good time to assess the orthogonality of the system as a whole. When you come across a problem, assess how localized the fix is.
- Orthogonality in documentation: The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content.
- Living with orthogonality: Orthogonality is closely related to the DRY principle. With DRY, you’re looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system’s components. If you use the principle of orthogonality, combined closely with the DRY principle, you’ll find that the systems you develop are more flexible, more understandable, and easier to debug, test, and maintain.

### Topic 11: Reversibility

- As time goes by, and your project progresses, you may find yourself stuck in an untenable position. With every critical decision, the project team commits to a smaller target—a narrower version of reality that has fewer options. By the time many critical decisions have been made, the target becomes so small that if it moves, or the wind changes direction, or a butterfly in Tokyo flaps its wings, you miss. And you may miss by a huge amount.
- There Are No Final Decisions: The mistake lies in assuming that any decision is cast in stone—and in not preparing for the contingencies that might arise. Instead of carving decisions in stone, think of them more as being written in the sand at the beach. A big wave can come along and wipe them out at any time.
- While many people try to keep their code flexible, you also need to think about maintaining flexibility in the areas of architecture, deployment, and vendor integration.
- Forgo Following Fads: No one knows what the future may hold, especially not us! So enable your code to rock-n-roll: to “rock on’’ when it can, to roll with the punches when it must.

### Topic 12: Tracer Bullets

- We use the term tracer bullet development to visually illustrate the need for immediate feedback under actual conditions with a moving goal.
- Because your users have never seen a system like this before, their requirements may be vague. Because you may be using algorithms, techniques, languages, or libraries you aren’t familiar with, you face a large number of unknowns. The classic response is to specify the system to death. Produce reams of paper itemizing every requirement, tying down every unknown, and constraining the environment. Fire the gun using dead reckoning. Pragmatic Programmers, however, tend to prefer using the software equivalent of tracer bullets.
- Tracer bullets work because they operate in the same environment and under the same constraints as the real bullets. To get the same effect in code, we look for something that gets us from a requirement to some aspect of the final system quickly, visibly, and repeatably.
- Look for the important requirements, the ones that define the system. Look for the areas where you have doubts, and where you see the biggest risks. Then prioritize your development so that these are the first areas you code.
- For us, the very first tracer bullet is simply create the project, add a “hello world!,” and make sure it compiles and runs. Then we look for areas of uncertainty in the overall application and add the skeleton needed to make it work.
- Tracer code is not disposable: you write it for keeps. It contains all the error checking, structuring, documentation, and selfchecking that any piece of production code has. It simply is not fully functional. However, once you have achieved an end-toend connection among the components of your system, you can check how close to the target you are, adjusting if necessary. Once you’re on target, adding functionality is easy.
- Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.
- The tracer code approach has many advantages: Users get to see something working early, Developers build a structure to work in, You have an integration platform, You have something to demonstrate, You have a better feel for progress.
- You might think that this tracer code concept is nothing more than prototyping under an aggressive name. There is a difference. With a prototype, you’re aiming to explore specific aspects of the final system. With a true prototype, you will throw away whatever you lashed together when trying out the concept, and recode it properly using the lessons you’ve learned. The tracer code approach addresses a different problem. You need to know how the application as a whole hangs together. You want to show your users how the interactions will work in practice, and you want to give your developers an architectural skeleton on which to hang code. The distinction is important enough to warrant repeating. Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.

### Topic 13: Prototypes and Post-it Notes

- We build software prototypes to analyze and expose risk, and to offer chances for correction at a greatly reduced cost. We can target a prototype to test one or more specific aspects of a project.
- We tend to think of prototypes as code-based, but they don’t always have to be. Post-it notes are great for prototyping dynamic things such as workflow and application logic. A user interface can be prototyped as a drawing on a whiteboard.
- Prototypes are designed to answer just a few questions, so they are much cheaper and faster to develop than applications that go into production. The code can ignore unimportant details— unimportant to you at the moment, but probably very important to the user later on.
- But if you find yourself in an environment where you cannot give up the details, then you need to ask yourself if you are really building a prototype at all. Perhaps a tracer bullet style of development would be more appropriate in this case.
- You can prototype: Architecture, New functionality in an existing system, Structure or contents of external data, Third-party tools or components, Performance issues, User interface design.
- When building a prototype, you can ignore: Correctness, Completeness, Robustness, Style.
- Here are some specific areas you may want to look for in the architectural prototype: Are the responsibilities of the major areas well defined and appropriate? Are the collaborations between major components well defined? Is coupling minimized? Can you identify potential sources of duplication? Are interface definitions and constraints acceptable? Does every module have an access path to the data it needs during execution? Does it have that access when it needs it?
- Before you embark on any code-based prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don’t know that they are just prototypes. You must make it very clear that this code is disposable, incomplete, and unable to be completed.
- If you feel there is a strong possibility in your environment or culture that the purpose of prototype code may be misinterpreted, you may be better off with the tracer bullet approach.

### Topic 15: Estimating

- 

###

###

###

## Chapter 3: The Basic Tools

###

###

## References

<a id="boswellfoucher2011">Boswell, D. & Foucher, T. (2011).</a>  
*The Art of Readable Code: Simple and Practical Techniques for Writing Better Code.*  
O'Reilly.