---
title: "Main lessons from 'The Pragmatic Programmer'"
date: 2025-12-07
category: Statistics, mathematics and computer science
layout: post
---

The objective of this guide is to compile quick summaries from Chapters 1-3 of **CITE**. The summaries do not replace the content of each chapter, but can be useful as quick reference points.

## Chapter 1: A Pragmatic Philosophy

### Topic 1: It's Your Life

- You have agency.
- Does your work environment suck? Is your job boring? Try to fix it. But don’t try forever.
- If technology seems to be passing you by, make time (in your own time) to study new stuff that looks interesting.
- Want to work remotely? Have you asked? If they say no, then find someone who says yes.\
- This industry gives you a remarkable set of opportunities. Be proactive, and take them.

### Topic 2: The Cat Ate My Source Code

- Despite thorough testing, good documentation, and solid automation, things go wrong. Deliveries are late. Unforeseen technical problems come up. These things happen, and we try to deal with them as professionally as we can. This means being honest and direct.
- Trust in a team is absolutely essential for creativity and collaboration.
- You have the right not to take on a responsibility for an impossible situation, or one in which the risks are too great, or the ethical implications too sketchy.
- When you do accept the responsibility for an outcome, you should expect to be held accountable for it. When you make a mistake (as we all do) or an error in judgment, admit it honestly and try to offer options.
- Don’t blame someone or something else, or make up an excuse.
- When you find yourself saying, “I don’t know,” be sure to follow it up with “—but I’ll find out.” It’s a great way to admit what you don’t know, but then take responsibility like a pro.

### Topic 3: Software Entropy

- Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered.
- Don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

### Topic 4: Stone Soup and Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes—you know it’s right. But ask permission to tackle the whole thing and you’ll be met with delays and blank stares.
- Work out what you can reasonably ask for. Develop it well. Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added…’’ Pretend it’s not important. Sit back and wait for them to start asking you to add the functionality you originally wanted.

### Topic 5: Good-Enough Software

- You can discipline yourself to write software that’s good enough—good enough for your users, for future maintainers, for your own peace of mind (the phrase "good enough" does not imply sloppy or poorly produced code).
- Involve your users in the trade-off: Sometimes there’ll be no choice. However, if you’re working on a brand-new product, you’ll have different constraints. Surprisingly, many users would rather use software with some rough edges today than wait a year for the shiny, bells-andwhistles version.
- Know when to stop: Don’t spoil a perfectly good program by overembellishment and overrefinement. Move on, and let your code stand in its own right for a while.


### Topic 6: Your Knowledge Portfolio

- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios.
- To be successful in your career, you must invest in your knowledge portfolio: Invest regularly, diversify, manage risk, buy low (sell high) and review and rebalance. 
- Suggested goals: Learn new languages, read technical books, read nontechnical books, take classes, participate in local user groups and meetups, experiment with different environments and stay current.
- Opportunities for learning: 
  - Somebody asks you a question. You don’t have the faintest idea what the answer is, and freely admit as much. Take it as a personal challenge to find the answer. Ask around. If you can’t find the answer yourself, find out who can.
  - Plan ahead. Always have something to read in an otherwise dead moment. Time spent waiting for doctors and dentists can be a great opportunity to catch up on your reading.
- Think critically about what you read and hear. Beware of the zealots who insist that their dogma provides the only answer. Just because a web search engine lists a hit first doesn’t mean that it’s the best match. Just because a bookstore features a book prominently doesn’t mean it’s a good book, or even popular.
- Suggested questions: Ask the "Five Whys". Who does this benefit? What’s the context? When or Where would this work? Why is this a problem?

### Topic 7: Communicate!

- Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people. A good idea is an orphan without effective communication.
- Know your audience: By making the appropriate pitch to each group, you’ll get them all excited about your project. As with all forms of communication, the trick here is to gather feedback. Don’t just wait for questions: ask for them. Look at body language, and facial expressions.
- Know what you want to say: Plan what you want to say. Write an outline. Then ask yourself, “Does this communicate what I want to express to my audience in a way that works for them?” Refine it until it does. When you’re faced with an important meeting or a chat with a major client, jot down the ideas you want to communicate, and plan a couple of strategies for getting them across.
- Choose your moment: As part of understanding what your audience needs to hear, you need to work out what their priorities are. Make what you’re saying relevant in time, as well as in content. Sometimes all it takes is the simple question, “Is this a good time to talk about…?’’
- Choose a style: Adjust the style of your delivery to suit your audience. Some people want a formal “just the facts’’ briefing. Others like a long, wide-ranging chat before getting down to business. What is their skill level and experience in this area? Are they experts? Newbies? Do they need hand-holding or just a quick tl;dr? If in doubt, ask.
- Make it look good: Your ideas are important. They deserve a good-looking vehicle to convey them to your audience. Learn how to set page headers and footers. Check the spelling, first automatically and then by hand.
- Involve your audience: We often find that the documents we produce end up being less important than the process we go through to produce them. If possible, involve your readers with early drafts of your document. Get their feedback, and pick their brains. You’ll build a good working relationship, and you’ll probably produce a better document in the process.
- Be a listener: There’s one technique that you must use if you want people to listen to you: listen to them. If you don’t listen to them, they won’t listen to you. Encourage people to talk by asking questions, or ask them to restate the discussion in their own words. Turn the meeting into a dialog, and you’ll make your point more effectively. Who knows, you might even learn something.
- Get back to people: how often do you fail to get back to people when they send you an email or a memo asking for information or requesting some action? In the rush of everyday life, it’s easy to forget. Always respond to emails and voicemails, even if the response is simply “I’ll get back to you later.’’
- Documentation: Pragmatic Programmers embrace documentation as an integral part of the overall development process. It’s easy to produce good-looking documentation from the comments in source code. Restrict your non-API commenting to discussing why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant. Commenting source code gives you the perfect opportunity to document those elusive bits of a project that can’t be documented anywhere else: engineering trade-offs, why decisions were made, what other alternatives were discarded, and so on.

## Chapter 2: A Pragmatic Approach

### Topic 8: The Essence of Good Design

- Good Design Is Easier to Change Than Bad Design.
- Easier to Change. ETC. Every design principle out there is a special case of ETC.
- ETC is a value, not a rule: it should be floating just behind your conscious thought, subtly nudging you in the right direction.
- You may need to spend a week or so deliberately asking yourself “did the thing I just did make the overall system easier or harder to change?”

### Topic 9: DRY - The Evils of Duplication

- When we perform maintenance, we have to find and change the representations of things—those capsules of knowledge embedded in the application. The problem is that it’s easy to duplicate knowledge in the specifications, processes, and programs that we develop, and when we do so, we invite a maintenance nightmare—one that starts well before the application ships.
- The only way to develop software reliably, and to make our developments easier to understand and maintain, is to follow what we call the DRY (Don’t Repeat Yourself) principle: Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
- The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others.
- Dry is more than code: DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.
- Make It Easy to Reuse: What you’re trying to do is foster an environment where it’s easier to find and reuse existing stuff than to write it yourself. If it isn’t easy, people won’t do it. And if you fail to reuse, you risk duplicating knowledge.

### Topic 10: Orthogonality

- In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap databases without changing the interface. Eliminate effects between unrelated things.
- Benefits of orthogonality: We want to design components that are self-contained (independent, and with a single, well-defined purpose). You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.
- Orthogonality in design: There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: If I dramatically change the requirements behind a particular function, how many modules are affected? In an orthogonal system, the answer should be “one.’ Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes?
- Orthogonality in toolkits and libraries: When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn’t be there.
- Orthogonality in coding: Every time you write code you run the risk of reducing the orthogonality of your application. There are several techniques you can use to maintain orthogonality: keep your code decoupled, avoid global data, avoid similar functions.
- Orthogonality in testing: Writing unit tests is itself an interesting test of orthogonality. What does it take to get a unit test to build and run? Do you have to import a large percentage of the rest of the system’s code? If so, you’ve found a module that is not well decoupled from the rest of the system. Bug fixing is also a good time to assess the orthogonality of the system as a whole. When you come across a problem, assess how localized the fix is.
- Orthogonality in documentation: The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content.
- Living with orthogonality: Orthogonality is closely related to the DRY principle. With DRY, you’re looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system’s components. If you use the principle of orthogonality, combined closely with the DRY principle, you’ll find that the systems you develop are more flexible, more understandable, and easier to debug, test, and maintain.

###

###

###

## Chapter 3: The Basic Tools

###

###

## References

<a id="boswellfoucher2011">Boswell, D. & Foucher, T. (2011).</a>  
*The Art of Readable Code: Simple and Practical Techniques for Writing Better Code.*  
O'Reilly.